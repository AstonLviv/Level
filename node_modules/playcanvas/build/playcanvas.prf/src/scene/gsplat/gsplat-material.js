import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { CULLFACE_NONE, SEMANTIC_POSITION, SEMANTIC_ATTR13 } from '../../platform/graphics/constants.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { DITHER_NONE, BLEND_NONE, BLEND_NORMAL, tonemapNames, GAMMA_NONE, GAMMA_SRGB } from '../constants.js';
import { ShaderMaterial } from '../materials/shader-material.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { getMaterialShaderDefines } from '../shader-lib/utils.js';
import { ShaderUtils } from '../../platform/graphics/shader-utils.js';
import { shaderChunks } from '../shader-lib/chunks/chunks.js';
import { ShaderGenerator } from '../shader-lib/programs/shader-generator.js';
import { ShaderPass } from '../shader-pass.js';
import { hashCode } from '../../core/hash.js';

const gammaNames = {
	[GAMMA_NONE]: 'NONE',
	[GAMMA_SRGB]: 'SRGB'
};
const defaultChunks = new Map(Object.entries(shaderChunks));
class GSplatShaderGenerator {
	generateKey(options) {
		const {
			pass,
			gamma,
			toneMapping,
			vertex,
			fragment,
			dither,
			defines,
			chunks
		} = options;
		return `splat-${pass}-${gamma}-${toneMapping}-${hashCode(vertex)}-${hashCode(fragment)}-${dither}-${ShaderGenerator.definesHash(defines)}-${chunks && Object.keys(chunks).sort().join(':')}`;
	}
	createShaderDefinition(device, options) {
		var _tonemapNames$options, _gammaNames$options$g, _options$vertex, _options$fragment;
		const shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);
		const shaderPassDefines = shaderPassInfo.shaderDefines;
		const defineMap = new Map();
		defineMap.set('TONEMAP', (_tonemapNames$options = tonemapNames[options.toneMapping]) != null ? _tonemapNames$options : true);
		defineMap.set('GAMMA', (_gammaNames$options$g = gammaNames[options.gamma]) != null ? _gammaNames$options$g : true);
		defineMap.set(`DITHER_${options.dither.toUpperCase()}`, true);
		options.defines.forEach((value, key) => {
			defineMap.set(key, value);
		});
		const defines = `${shaderPassDefines}\n`;
		const vs = defines + ((_options$vertex = options.vertex) != null ? _options$vertex : shaderChunks.gsplatVS);
		const fs = defines + ((_options$fragment = options.fragment) != null ? _options$fragment : shaderChunks.gsplatPS);
		const includes = options.chunks ? new Map(Object.entries(_extends({}, shaderChunks, options.chunks))) : defaultChunks;
		return ShaderUtils.createDefinition(device, {
			name: 'SplatShader',
			attributes: {
				vertex_position: SEMANTIC_POSITION,
				vertex_id_attrib: SEMANTIC_ATTR13
			},
			vertexCode: vs,
			vertexDefines: defineMap,
			vertexIncludes: includes,
			fragmentCode: fs,
			fragmentDefines: defineMap,
			fragmentIncludes: includes
		});
	}
}
const gsplat = new GSplatShaderGenerator();
const createGSplatMaterial = (options = {}) => {
	var _options$dither;
	const ditherEnum = (_options$dither = options.dither) != null ? _options$dither : DITHER_NONE;
	const dither = ditherEnum !== DITHER_NONE;
	const material = new ShaderMaterial();
	material.name = 'splatMaterial';
	material.cull = CULLFACE_NONE;
	material.blendType = dither ? BLEND_NONE : BLEND_NORMAL;
	material.depthWrite = dither;
	material.getShaderVariant = function (params) {
		const {
			cameraShaderParams
		} = params;
		const programOptions = {
			defines: getMaterialShaderDefines(material, cameraShaderParams),
			pass: params.pass,
			gamma: cameraShaderParams.shaderOutputGamma,
			toneMapping: cameraShaderParams.toneMapping,
			vertex: options.vertex,
			fragment: options.fragment,
			chunks: options.chunks,
			dither: ditherEnum
		};
		const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
		const library = getProgramLibrary(params.device);
		library.register('splat', gsplat);
		return library.getProgram('splat', programOptions, processingOptions);
	};
	material.update();
	return material;
};

export { createGSplatMaterial };

import { PIXELFORMAT_R32F, PIXELFORMAT_RGBA8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { LAYERID_DEPTH, SHADER_PREPASS } from '../../scene/constants.js';
import { Color } from '../../core/math/color.js';

const tempMeshInstances = [];
const DEPTH_UNIFORM_NAME = 'uSceneDepthMap';
class RenderPassPrepass extends RenderPass {
	constructor(device, scene, renderer, camera, options) {
		super(device);
		this.viewBindGroups = [];
		this.linearDepthTexture = void 0;
		this.linearDepthClearValue = void 0;
		this.scene = scene;
		this.renderer = renderer;
		this.camera = camera;
		this.setupRenderTarget(options);
	}
	destroy() {
		var _this$renderTarget, _this$linearDepthText;
		super.destroy();
		(_this$renderTarget = this.renderTarget) == null || _this$renderTarget.destroy();
		this.renderTarget = null;
		(_this$linearDepthText = this.linearDepthTexture) == null || _this$linearDepthText.destroy();
		this.linearDepthTexture = null;
		this.viewBindGroups.forEach(bg => {
			bg.defaultUniformBuffer.destroy();
			bg.destroy();
		});
		this.viewBindGroups.length = 0;
	}
	setupRenderTarget(options) {
		const {
			device
		} = this;
		const linearDepthFormat = device.textureFloatRenderable ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;
		this.linearDepthTexture = new Texture(device, {
			name: 'SceneLinearDepthTexture',
			width: 1,
			height: 1,
			format: linearDepthFormat,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		const renderTarget = new RenderTarget({
			name: 'PrepassRT',
			colorBuffer: this.linearDepthTexture,
			depth: true,
			samples: 1
		});
		this.camera.shaderParams.sceneDepthMapLinear = true;
		this.init(renderTarget, options);
		this.linearDepthClearValue = new Color(linearDepthFormat === PIXELFORMAT_R32F ? [1, 1, 1, 1] : [0.5, 0.0, 0.0, 0.0]);
	}
	after() {
		this.device.scope.resolve(DEPTH_UNIFORM_NAME).setValue(this.linearDepthTexture);
	}
	execute() {
		const {
			renderer,
			scene,
			renderTarget
		} = this;
		const camera = this.camera.camera;
		const layers = scene.layers.layerList;
		const subLayerEnabled = scene.layers.subLayerEnabled;
		const isTransparent = scene.layers.subLayerList;
		for (let i = 0; i < layers.length; i++) {
			const layer = layers[i];
			if (layer.id === LAYERID_DEPTH) {
				break;
			}
			if (layer.enabled && subLayerEnabled[i]) {
				if (layer.camerasSet.has(camera)) {
					const culledInstances = layer.getCulledInstances(camera);
					const meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;
					for (let j = 0; j < meshInstances.length; j++) {
						var _meshInstance$materia;
						const meshInstance = meshInstances[j];
						if ((_meshInstance$materia = meshInstance.material) != null && _meshInstance$materia.depthWrite) {
							tempMeshInstances.push(meshInstance);
						}
					}
					renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_PREPASS, this.viewBindGroups, {
						meshInstances: tempMeshInstances
					});
					tempMeshInstances.length = 0;
				}
			}
		}
	}
	frameUpdate() {
		super.frameUpdate();
		const {
			camera
		} = this;
		this.setClearDepth(camera.clearDepthBuffer ? 1 : undefined);
		this.setClearColor(camera.clearDepthBuffer ? this.linearDepthClearValue : undefined);
	}
}

export { RenderPassPrepass };
